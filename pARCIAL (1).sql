USE GD2015C1

--PUNTO 1

SELECT 
--1) DETALLE
P.prod_detalle,
--2) RUBRO
R.rubr_detalle,
--3) CANTIDAD DE VECES VENDIDO. ASUMO QUE SE REFIERE A LA CANTIDAD DE UNIDADES VENDIDAS, Y NO A LA CANTIDAD DE FACTURAS EN LAS QUE ESTÁ
(SELECT ISNULL(SUM(item_cantidad),0) FROM Item_Factura I WHERE I.item_producto = P.prod_codigo)
FROM Producto P 
JOIN Rubro R ON R.rubr_id = P.prod_rubro
WHERE P.prod_codigo IN (SELECT C1.comp_producto FROM Producto P1
						JOIN Composicion C1 ON C1.comp_producto = P1.prod_codigo
						GROUP BY C1.comp_producto
						HAVING COUNT(DISTINCT C1.comp_componente) > 2
						)
ORDER BY (SELECT COUNT(DISTINCT C2.comp_componente) 
			FROM Composicion C2 
			WHERE C2.comp_producto = P.prod_codigo
			)
--EN MI BASE NO DEVUELVE NADA PORQUE NO HAY PRODUCTOS CON MAS DE 2 COMPONENTES DISTINTOS

-- PUNTO 2
ALTER FUNCTION validar_subordinados(@idEmpl numeric(6))
RETURNS BIT
AS 
BEGIN
	--UN EMPLEADO ES JEFE SI TIENE PERSONAS A CARGO, SI TIENE 0 PERSONAS A CARGO NO ES JEFE, 
	--POR LO TANTO NO TIENE SENTIDO RESTRINGIR QUE UN JEFE NO TENGA MENOS DE 1 PERSONA A CARGO PORQUE DEJARIA DE SER JEFE
	DECLARE @cantSubordinados int
	SET @cantSubordinados = (SELECT COUNT(*) FROM Empleado WHERE empl_jefe = @idEmpl)
	IF (@cantSubordinados < 21) 
	BEGIN
		RETURN 1	
	END
	RETURN 0
END

ALTER TABLE Empleado
ADD CONSTRAINT cant_subordinados
CHECK (DBO.validar_subordinados(empl_codigo) = 1)
--ESTO PUEDE DAR ERROR SI HAY REGISTROS EN LA TABLA QUE NO CUMPLEN LA RESTRICCION, 
--PERO ACORDAMOS ASUMIR QUE EL EJERCICIO NO ES RETROACTIVO

CREATE TRIGGER trJefes ON Empleado AFTER UPDATE
AS IF UPDATE(empl_jefe)
	BEGIN TRANSACTION  --UNA VEZ QUE EL EMPLEADO SE INSERTÓ EN LA TABLA, AHORA SE PUEDE SABER SI ES JEFE O NO, 
					   --POR LO TANTO LA RESTRICCION DE QUE LA CANTIDAD DE SUBORDINADOS SEA >= 1 SE PUEDE HACER A PARTIR DE AHORA
	
	DECLARE @idEmpl numeric(6), @idJefe numeric(6)
	DECLARE @cantSubordinados int
	DECLARE miCursor CURSOR FOR SELECT empl_codigo, empl_jefe FROM inserted
	OPEN miCursor
	FETCH miCursor INTO @idEmpl, @idJefe
	WHILE(@@FETCH_STATUS =0)
	BEGIN
		SET @cantSubordinados = (SELECT COUNT(*) FROM Empleado WHERE empl_jefe = @idEmpl)	
		IF (@cantSubordinados > 20 OR @cantSubordinados <1) 
		BEGIN
			ROLLBACK			
		END
	END
	CLOSE miCursor
	DEALLOCATE miCursor
COMMIT



--PUNTO 3
--PORQUE, PARA EL CASO DE SELECT *, EL MOTOR TIENE QUE ALCANZAR ESE NODO DENTRO DEL ARBOL B Y RECUPERAR SUS DATOS,
--EN CAMBIO PARA EL CASO DE SELECT ID, SOLAMENTE NECESITA AVERIGUAR SI EXISTE EL NODO, 
--YA QUE LO QUE TIENE QUE RECUPERAR ES SOLO EL ID, QUE YA LO RECIBIO EN EL WHERE
--PARA ESO, SOLO TIENE QUE RECORRER EL ARBOL HASTA EL NODO DONDE ESTARÍA EL ID 1, Y NO NECESITA ENTRAR A DISCO A BUSCAR LOS DEMAS DATOS DE ESE REGISTRO

--Y SI NO EXISTIERA EL ID 1, AMBOS CASOS SERIAN EXACTAMENTE IGUALES